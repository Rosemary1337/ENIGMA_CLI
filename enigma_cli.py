#!/usr/bin/env python3
"""
███████╗███╗   ██╗██╗ ██████╗ ███╗   ███╗ █████╗          ██████╗██╗     ██╗
██╔════╝████╗  ██║██║██╔════╝ ████╗ ████║██╔══██╗        ██╔════╝██║     ██║
█████╗  ██╔██╗ ██║██║██║  ███╗██╔████╔██║███████║        ██║     ██║     ██║
██╔══╝  ██║╚██╗██║██║██║   ██║██║╚██╔╝██║██╔══██║        ██║     ██║     ██║
███████╗██║ ╚████║██║╚██████╔╝██║ ╚═╝ ██║██║  ██║███████╗╚██████╗███████╗██║
╚══════╝╚═╝  ╚═══╝╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚══════╝╚═╝
    A comprehensive security reconnaissance tool for bug bounty hunters
"""

import sys
import os
import re
import platform
import psutil
import argparse
import subprocess
import json
from datetime import datetime
from pathlib import Path
import time
import threading
from itertools import cycle
import threading
import time


try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

# --- Tab Descriptions for AI Context ---
TAB_DESCRIPTIONS = {
    "Enumeration": (
        "The Enumeration tab helps you discover subdomains for a target domain using tools like Subfinder and Assetfinder. "
        "It merges results, checks which subdomains are alive, and saves all valid subdomains to output/enumeration/<target>."
    ),
    "Information": (
        "The Information tab gathers WHOIS and registration data for a domain. "
        "It helps you understand ownership, registration dates, and contact details."
    ),
    "Crawling": (
        "The Crawling tab discovers hidden paths and endpoints using live crawling (katana) and archive crawling (waybackurls). "
        "It helps you find admin panels, APIs, and old endpoints."
    ),
    "Path Finder": (
        "The Path Finder tab identifies sensitive files and directories on a web server, such as admin panels or backups."
    ),
    "SSL/TLS": (
        "The SSL/TLS tab scans SSL/TLS configurations to find weak ciphers, expired certificates, and insecure protocols."
    ),
    "Output Viewer": (
        "The Output Viewer tab lets you browse and review all output files generated by other modules."
    ),
    "Settings": (
        "The Settings tab allows you to change the theme and view system information."
    ),
}

def print_header():
    """Print the ENIGMA header"""
    print("""███████╗███╗   ██╗██╗ ██████╗ ███╗   ███╗ █████╗          ██████╗██╗     ██╗
██╔════╝████╗  ██║██║██╔════╝ ████╗ ████║██╔══██╗        ██╔════╝██║     ██║
█████╗  ██╔██╗ ██║██║██║  ███╗██╔████╔██║███████║        ██║     ██║     ██║
██╔══╝  ██║╚██╗██║██║██║   ██║██║╚██╔╝██║██╔══██║        ██║     ██║     ██║
███████╗██║ ╚████║██║╚██████╔╝██║ ╚═╝ ██║██║  ██║███████╗╚██████╗███████╗██║
╚══════╝╚═╝  ╚═══╝╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚══════╝╚═╝""")
    print("ENIGMA - CLI Version")
    print(" A comprehensive security reconnaissance tool for bug bounty hunters")
    print()

def print_banner(title):
    """Print a banner for each module command"""
    print("\n" + "="*60)
    print(f" {title}")
    print("="*60)

def show_loading_animation(stop_event, message="Processing"):
    """Show a loading animation while a process is running"""
    for char in cycle(["◜","◝","◞","◟"]):
        if stop_event.is_set():
            break
        sys.stdout.write(f'\r{message} {char}')
        sys.stdout.flush()
        time.sleep(0.1)
    sys.stdout.write('\r')  # Clear the loading line

def print_progress_bar(iteration, total, prefix='Progress:', suffix='Complete', decimals=1, length=50, fill='█', print_end="\r"):
    """
    Call in a loop to create terminal progress bar
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filled_length = int(length * iteration // total)
    bar = fill * filled_length + '-' * (length - filled_length)
    sys.stdout.write(f'\r{prefix} |{bar}| {percent}% {suffix}')
    sys.stdout.flush()
    
    # Print New Line on Complete
    if iteration == total: 
        print()

def execute_command(cmd, target=None, output_file=None, tool_name="Tool"):
    """Execute a command with loading animation and better output"""
    print(f"[{datetime.now().strftime('%H:%M:%S')}] Starting {tool_name}...")
    
    # Start loading animation in a separate thread
    stop_event = threading.Event()
    loading_thread = threading.Thread(target=show_loading_animation, args=(stop_event, f"  Running {tool_name}"))
    loading_thread.start()
    
    try:
        # Split the command into shell command
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True,
            env={**os.environ, "PATH": os.environ.get("PATH", "")}
        )
        
        # Stop loading animation
        stop_event.set()
        loading_thread.join()
        
        # Clear the loading line
        sys.stdout.write('\r')
        sys.stdout.flush()
        
        # Print stdout if it exists
        if result.stdout:
            # Only print if not too verbose (for cleaner output)
            lines = result.stdout.strip().split('\n')
            if len(lines) < 10:
                # Show all output if it's short
                print(f"[+] {tool_name} completed successfully.")
                if result.stdout.strip():  # Only print if there's actual content
                    print(result.stdout)
            else:
                # For verbose output, just show a summary
                print(f"[+] {tool_name} completed. Found {len(lines)} results.")
        
        # Print stderr if it exists (for errors/warnings)
        if result.stderr:
            print(f"[ERROR] {result.stderr}")
        
        # Save to file if specified
        if output_file and result.stdout:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            with open(output_file, 'w') as f:
                f.write(result.stdout)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Output saved to {output_file}")
        
        return result.returncode == 0
    except Exception as e:
        # Stop loading animation in case of exception
        stop_event.set()
        loading_thread.join()
        
        # Clear the loading line
        sys.stdout.write('\r')
        sys.stdout.flush()
        
        print(f"[ERROR] Failed to execute command: {e}")
        return False

def enumerate_subdomains(target):
    """Enumerate subdomains for a target domain"""
    print_banner("[ENUMERATION MODULE]")
    print("Enumeration is the first and most critical phase of reconnaissance in any security assessment.")
    print("In this module, Enigma helps you identify publicly available subdomains belonging to a target domain,")
    print("using multiple powerful tools like Subfinder and Assetfinder.")
    print("\nAfter gathering subdomains, Enigma can check for potentially vulnerable dangling DNS records using")
    print("Subjack and Subzy, tools commonly used in subdomain takeover detection.")
    print("\nTo streamline your workflow, Enigma automatically merges results from multiple tools")
    print("and allows you to probe live subdomains with HTTPX to validate which hosts are responsive.")
    print("\nStarting enumeration...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return
    
    base_path = f'output/enumeration/{target}'
    os.makedirs(base_path, exist_ok=True)

    # Run Subfinder
    subfinder_file = os.path.join(base_path, "subfinder.txt")
    success1 = execute_command(f"subfinder -d {target} -o {subfinder_file}", target, subfinder_file, "Subfinder")

    # Run Assetfinder
    assetfinder_file = os.path.join(base_path, "assetfinder.txt")
    success2 = execute_command(f"assetfinder --subs-only {target} > {assetfinder_file}", target, assetfinder_file, "Assetfinder")

    if success1 or success2:
        print("[*] Enumeration started. Use --merge-results to merge results after tools finish.")
    else:
        print("[!] Both tools failed to run.")

def merge_subdomain_files(target):
    """Merge subdomain files from multiple tools"""
    print_banner("[ENUMERATION - MERGE RESULTS]")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    base_path = f'output/enumeration/{target}'
    subfinder_file = os.path.join(base_path, "subfinder.txt")
    assetfinder_file = os.path.join(base_path, "assetfinder.txt")
    merged_file = os.path.join(base_path, "all_subs.txt")

    all_domains = set()
    
    for file in [subfinder_file, assetfinder_file]:
        if os.path.exists(file):
            with open(file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith("http://") or line.startswith("https://"):
                        line = re.sub(r'^https?://', '', line)
                        line = line.split('/')[0]
                    if re.match(r'^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', line):
                        all_domains.add(line)

    with open(merged_file, 'w') as f:
        for domain in sorted(all_domains):
            f.write(f"{domain}\n")

    print(f"[+] Merged {len(all_domains)} valid domains into {merged_file}")

def check_alive_subdomains(target):
    """Check which subdomains are alive"""
    print_banner("[ENUMERATION - CHECK ALIVE]")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    base_path = f'output/enumeration/{target}'
    infile = os.path.join(base_path, "all_subs.txt")
    outfile = os.path.join(base_path, "alive.txt")

    if not os.path.isfile(infile):
        print("[!] all_subs.txt not found. Run --merge-results first.")
        return

    cmd = f"cat {infile} | httpx -silent -threads 100 -timeout 5 -no-color -o {outfile}"
    success = execute_command(cmd, target, outfile, "HTTPX (checking alive subdomains)")
    
    if success:
        print(f"[*] Checking alive subdomains. Results saved to {outfile}.")
    else:
        print("[!] Failed to check alive subdomains.")

def run_whois(target):
    """Run WHOIS query to collect domain information"""
    print_banner("[INFORMATION MODULE]")
    print("This module is designed to help you gather essential domain registration")
    print("and ownership data using WHOIS lookups. It is a critical step in passive")
    print("reconnaissance, allowing you to retrieve registrar information, creation and")
    print("expiration dates, name servers, and contact details if available.")
    print("\nKnowing who owns a domain and when it was registered can help identify")
    print("potential targets, expired domains, or interesting patterns in the organization's")
    print("domain infrastructure.")
    print("\nStarting WHOIS lookup...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return
        
    os.makedirs(f"output/information/{target}", exist_ok=True)
    output_file = f"output/information/{target}/information.txt"
    cmd = f"whois {target}"
    success = execute_command(cmd, target, output_file, "WHOIS")
    
    if success:
        print(f"[*] WHOIS lookup completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run WHOIS lookup.")

def run_katana(target):
    """Run live crawling with katana"""
    print_banner("[CRAWLING MODULE - LIVE]")
    print("This module allows you to discover hidden paths, parameters, endpoints,")
    print("and archived content from both live and historical sources.")
    print("\nLive crawling uses 'katana' to scan reachable URLs and endpoints in real-time,")
    print("while archive crawling leverages 'waybackurls' to gather URLs from the Internet Archive.")
    print("\nThese methods help uncover admin panels, hidden directories, old APIs, or endpoints")
    print("that are no longer linked but still accessible.")
    print("\nStarting live crawling...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return
        
    os.makedirs(f"output/crawling/{target}/", exist_ok=True)
    outfile = f"output/crawling/{target}/live_crawling.txt"
    cmd = f"echo {target} | katana | tee {outfile}"
    success = execute_command(cmd, target, outfile, "Katana (live crawling)")
    
    if success:
        print(f"[*] Live crawling completed. Results saved to {outfile}")
    else:
        print("[!] Failed to run live crawling.")

def run_waybackurls(target):
    """Run archive crawling with waybackurls"""
    print_banner("[CRAWLING MODULE - ARCHIVE]")
    
    if not target:
        print("[!] Please provide a target domain.")
        return
        
    os.makedirs(f"output/crawling/{target}/", exist_ok=True)
    outfile = f"output/crawling/{target}/archive_crawling.txt"
    cmd = f"echo {target} | waybackurls | tee {outfile}"
    success = execute_command(cmd, target, outfile, "Waybackurls (archive crawling)")
    
    if success:
        print(f"[*] Archive crawling completed. Results saved to {outfile}")
    else:
        print("[!] Failed to run archive crawling.")

def run_admin_finder(target):
    """Run admin finder to identify sensitive paths"""
    print_banner("[PATH FINDER MODULE]")
    print("This module helps you identify accessible files, folders, and potential hidden")
    print("resources within a web server. It uses techniques such as directory brute-forcing")
    print("to uncover admin panels, configuration files, backups, and other sensitive paths.")
    print("\nDiscovering these hidden endpoints can often lead to privilege escalation,")
    print("information leakage, or even direct exploitation vectors.")
    print("\nStarting path finder...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/pathfinder/{target}", exist_ok=True)
    output_file = f"output/pathfinder/{target}/paths.txt"
    
    # Assuming target starts with https:// if not provided
    if not target.startswith("http://") and not target.startswith("https://"):
        target_url = f"https://{target}"
    else:
        target_url = target
    
    cmd = f"okadminfinder -u {target_url}"
    success = execute_command(cmd, target, output_file, "OkAdminFinder")
    
    if success:
        print(f"[*] Path finder completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run path finder.")

def run_sslscan(target):
    """Run SSL scan to check SSL/TLS configurations"""
    print_banner("[SSL/TLS SCANNER MODULE]")
    print("This module scans SSL/TLS configurations of a given host using sslscan.")
    print("It helps identify insecure protocols, weak ciphers, expired certificates,")
    print("and other misconfigurations that could compromise secure communications.")
    print("\nUnderstanding SSL/TLS posture is critical in securing modern web applications,")
    print("especially for domains handling sensitive user data or financial transactions.")
    print("\nStarting SSL scan...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/sslscan/{target}", exist_ok=True)
    output_file = f"output/sslscan/{target}/sslscan.txt"
    cmd = f"sslscan --no-colour {target}"
    success = execute_command(cmd, target, output_file, "SSLScan")
    
    if success:
        print(f"[*] SSL scan completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run SSL scan.")

def run_nuclei(target):
    """Run Nuclei vulnerability scanner"""
    print_banner("[NUCLEI VULNERABILITY SCANNER]")
    print("Nuclei is a fast, customizable vulnerability scanner based on simple YAML based templates.")
    print("It enables systematic scanning for vulnerabilities across targets at a large scale.")
    print("\nStarting Nuclei scan...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/vulnerability/{target}", exist_ok=True)
    output_file = f"output/vulnerability/{target}/nuclei.txt"
    cmd = f"echo {target} | nuclei -silent -o {output_file}"
    success = execute_command(cmd, target, output_file, "Nuclei (vulnerability scanner)")
    
    if success:
        print(f"[*] Nuclei scan completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run Nuclei scan.")

def run_subjack(target):
    """Run Subjack for subdomain takeover detection"""
    print_banner("[SUBJACK - SUBDOMAIN TAKEOVER]")
    print("Subjack is a tool written in Go to quickly and easily enumerate HTTP and HTTPS URLs.")
    print("It helps detect potential subdomain takeover vulnerabilities.")
    print("\nStarting Subjack scan...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    base_path = f'output/enumeration/{target}'
    input_file = os.path.join(base_path, "all_subs.txt")
    output_file = f"output/takeover/{target}/subjack.txt"

    if not os.path.isfile(input_file):
        print("[!] all_subs.txt not found. Run enumeration and merge results first.")
        return

    os.makedirs(f"output/takeover/{target}", exist_ok=True)
    cmd = f"subjack -w {input_file} -t 100 -timeout 30 -o {output_file} -ssl"
    success = execute_command(cmd, target, output_file, "Subjack (subdomain takeover)")
    
    if success:
        print(f"[*] Subjack scan completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run Subjack.")

def run_httpx(target):
    """Run Httpx for probing alive hosts"""
    print_banner("[HTTPX - PROBE ALIVE HOSTS]")
    print("HTTPX is a fast and multi-purpose HTTP toolkit that allows running multiple probes.")
    print("It can probe for open ports, detect technologies, and identify alive hosts.")
    print("\nStarting HTTPX probe...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/httpx/{target}", exist_ok=True)
    output_file = f"output/httpx/{target}/httpx.txt"
    cmd = f"echo {target} | httpx -silent -title -status-code -tech-detect -o {output_file}"
    success = execute_command(cmd, target, output_file, "HTTPX probe")
    
    if success:
        print(f"[*] HTTPX probe completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run HTTPX.")

def run_gau(target):
    """Run GetAllURLs to fetch known URLs from multiple sources"""
    print_banner("[GAU - GETALLURLS]")
    print("GAU fetches known URLs from multiple sources including AlienVault's OTX, CommonCrawl, and URLScan.io.")
    print("It helps gather URLs associated with a domain from various sources.")
    print("\nStarting GAU...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/gau/{target}", exist_ok=True)
    output_file = f"output/gau/{target}/gau.txt"
    cmd = f"echo {target} | gau | tee {output_file}"
    success = execute_command(cmd, target, output_file, "GAU (Get All URLs)")
    
    if success:
        print(f"[*] GAU completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run GAU.")

def run_amass(target):
    """Run Amass for comprehensive enumeration"""
    print_banner("[AMASS - COMPREHENSIVE ENUMERATION]")
    print("Amass performs systematic enumeration of DNS names to discover targets.")
    print("It uses multiple techniques to gain DNS and infrastructure information.")
    print("\nStarting Amass...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/amass/{target}", exist_ok=True)
    output_file = f"output/amass/{target}/amass.txt"
    cmd = f"amass enum -d {target} -o {output_file}"
    success = execute_command(cmd, target, output_file, "Amass (comprehensive enumeration)")
    
    if success:
        print(f"[*] Amass enumeration completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run Amass.")

def run_technology_detection(target):
    """Run technology detection with whatweb"""
    print_banner("[TECHNOLOGY DETECTION]")
    print("Detecting technologies used by the target website.")
    print("\nStarting technology detection...")
    
    if not target:
        print("[!] Please provide a target domain.")
        return

    os.makedirs(f"output/technologies/{target}", exist_ok=True)
    output_file = f"output/technologies/{target}/technologies.txt"
    cmd = f"whatweb -a 3 {target} --log-verbose={output_file}"
    success = execute_command(cmd, target, output_file, "WhatWeb (technology detection)")
    
    if success:
        print(f"[*] Technology detection completed. Results saved to {output_file}")
    else:
        print("[!] Failed to run technology detection.")

def list_outputs():
    """List all output files in the output directory using tree command"""
    print_banner("[OUTPUT VIEWER MODULE]")
    print("This module allows you to quickly browse and review output files generated")
    print("by other modules in Enigma. All scans and tools store their results under")
    print("the organized output/ directory structure.")
    print("\nListing output files...")
    
    output_path = Path("output")
    if not output_path.exists():
        print("[!] Output directory does not exist.")
        return
    
    print("\nOutput directory structure:")
    try:
        result = subprocess.run(["tree", "output"], capture_output=True, text=True)
        if result.returncode == 0:
            print(result.stdout)
        else:
            # Fallback to manual listing if tree command is not available
            print("tree command not found, using manual listing...")
            for root, dirs, files in os.walk(output_path):
                level = root.replace(str(output_path), '').count(os.sep)
                indent = ' ' * 2 * level
                print(f"{indent}{os.path.basename(root)}/")
                subindent = ' ' * 2 * (level + 1)
                for file in files:
                    print(f"{subindent}{file}")
    except FileNotFoundError:
        # Fallback to manual listing if tree command is not available
        print("tree command not found, using manual listing...")
        for root, dirs, files in os.walk(output_path):
            level = root.replace(str(output_path), '').count(os.sep)
            indent = ' ' * 2 * level
            print(f"{indent}{os.path.basename(root)}/")
            subindent = ' ' * 2 * (level + 1)
            for file in files:
                print(f"{subindent}{file}")

def show_file_content(file_path):
    """Show content of a specific output file"""
    if not os.path.exists(file_path):
        print(f"[!] File {file_path} does not exist.")
        return
    
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            filename = os.path.basename(file_path).lower()
            
            print(f"\nContent of {file_path}:")
            print("-" * 40)
            
            if "information" in filename or "sslscan" in filename:
                print(content)
            else:
                # Filter to show only URLs if it's not info or sslscan
                lines = content.strip().split('\n')
                url_pattern = re.compile(r'^(https?://[^ ]+|[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$')
                filtered_lines = [
                    line.strip() for line in lines
                    if url_pattern.match(line.strip()) and 'projectdiscovery.io' not in line
                ]
                
                if filtered_lines:
                    print('\n'.join(filtered_lines))
                else:
                    print(content)
    except Exception as e:
        print(f"[!] Cannot open file: {e}")

def get_system_info():
    """Get system information"""
    info = []
    info.append(f"OS: {platform.system()} {platform.release()}")
    info.append(f"Architecture: {platform.machine()}")
    info.append(f"CPU Cores: {psutil.cpu_count(logical=True)}")
    info.append(f"Total RAM: {round(psutil.virtual_memory().total / (1024 ** 3), 2)} GB")
    info.append(f"Hostname: {platform.node()}")
    info.append(f"Kernel: {platform.version()}")
    return "\n".join(info)

def get_usage_info():
    """Get real-time system usage"""
    cpu = psutil.cpu_percent(interval=0.5)
    ram = psutil.virtual_memory()
    used_ram = round(ram.used / (1024 ** 3), 2)
    total_ram = round(ram.total / (1024 ** 3), 2)
    usage_text = f"CPU Usage: {cpu}%\nRAM Usage: {used_ram} GB / {total_ram} GB"
    return usage_text

def get_app_info():
    """Get application information"""
    info = []
    info.append("Developed by @Rosemary1337")
    info.append("Version: 1.0")
    info.append("Telegram: @stupidp3rson")
    info.append("TikTok: @justan0therlover")
    info.append("Note: Use this tool at your own risk. The developer is not responsible for any illegal activities.")
    return "\n".join(info)

def show_settings():
    """Show settings and system information"""
    print_banner("[SETTINGS MODULE]")
    print("\nSystem Information:")
    print("-" * 20)
    print(get_system_info())
    
    print("\nReal-time Usage:")
    print("-" * 15)
    print(get_usage_info())
    
    print("\nInformation:")
    print("-" * 11)
    print(get_app_info())

def run_ai_assistant(query, api_key=None):
    """Run AI assistant functionality"""
    print_banner("[ENIGMAI - AI ASSISTANT]")
    if not OPENAI_AVAILABLE:
        print("[!] OpenAI library not available. Install with 'pip install openai'")
        return
    
    if not api_key:
        # Try to load API key from file
        if os.path.exists("openai_apikey.txt"):
            with open("openai_apikey.txt", "r") as f:
                api_key = f.read().strip()
        else:
            print("[!] No OpenAI API key provided. Set with --api-key or save to openai_apikey.txt")
            return
    
    if not api_key:
        print("[!] No OpenAI API key available. Get your key at: https://platform.openai.com/api-keys")
        return
    
    print("EnigmAI is your specialized AI assistant for bug bounty, red teaming, and hacking.")
    print("Asking your question to the AI...")
    
    # Add context about tabs if user asks about them
    context = ""
    for tab, desc in TAB_DESCRIPTIONS.items():
        if tab.lower() in query.lower():
            context += f"\n\nAbout the '{tab}' tab: {desc}"
    
    system_prompt = (
        "You are EnigmAI, an expert AI assistant for bug hunters, red teamers, and hackers. "
        "You provide concise, actionable, and technically accurate answers about security, "
        "reconnaissance, exploitation, and hacking tools. Always be practical and direct."
        "your answers are neatly structured, not just plaintext"
        "You are an AI assistant for ENIGMA, ENIGMA is a red teaming tool, this tool contains tabs or special tools for bug hunters, if the user asks for a guide for ENIGMA, focus on the list of tabs or tools available"
        "Your developer is KiddTheReaper, you are a tools, ai assistant in tool for bug hunters, red teamers and hackers named ENIGMA."
        f"""Tabs available in ENIGMA are:
        Enumeration:
            The Enumeration tab helps you discover subdomains for a target domain using tools like Subfinder and Assetfinder. 
            It merges results, checks which subdomains are alive, and saves all valid subdomains to output/enumeration/<target>.
        Information:
            The Information tab gathers WHOIS and registration data for a domain. 
            It helps you understand ownership, registration dates, and contact details.
        Crawling: 
            The Crawling tab discovers hidden paths and endpoints using live crawling (katana) and archive crawling (waybackurls). 
            It helps you find admin panels, APIs, and old endpoints.
        Path Finder:
            The Path Finder tab identifies sensitive files and directories on a web server, such as admin panels or backups.
        SSL/TLS: 
            The SSL/TLS tab scans SSL/TLS configurations to find weak ciphers, expired certificates, and insecure protocols.
        Output Viewer:
            The Output Viewer tab lets you browse and review all output files generated by other modules.
        Settings:
            The Settings tab allows you to change the theme and view system information."""
        + context
    )
    
    try:
        client = OpenAI(api_key=api_key)
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": query}
            ],
            stream=False,
        )
        
        ai_reply = response.choices[0].message.content.strip()
        print(f"\nEnigmAI: {ai_reply}")
        
    except Exception as e:
        print(f"[!] Error communicating with AI: {e}")



def main():
    parser = argparse.ArgumentParser(
        description="""███████╗███╗   ██╗██╗ ██████╗ ███╗   ███╗ █████╗          ██████╗██╗     ██╗
██╔════╝████╗  ██║██║██╔════╝ ████╗ ████║██╔══██╗        ██╔════╝██║     ██║
█████╗  ██╔██╗ ██║██║██║  ███╗██╔████╔██║███████║        ██║     ██║     ██║
██╔══╝  ██║╚██╗██║██║██║   ██║██║╚██╔╝██║██╔══██║        ██║     ██║     ██║
███████╗██║ ╚████║██║╚██████╔╝██║ ╚═╝ ██║██║  ██║███████╗╚██████╗███████╗██║
╚══════╝╚═╝  ╚═══╝╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚══════╝╚═╝""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python enigma_cli.py enum --target example.com
  python enigma_cli.py enum --target example.com --merge-results
  python enigma_cli.py info --target example.com
  python enigma_cli.py crawl --target example.com --live
  python enigma_cli.py path --target example.com
  python enigma_cli.py ssl --target example.com
  python enigma_cli.py output --list
  python enigma_cli.py ai --query "How to find subdomains?"
  python enigma_cli.py settings
        """
    )
    
    subparsers = parser.add_subparsers(dest='module', help='Module to run', required=True)
    
    # Enumeration module
    enum_parser = subparsers.add_parser('enum', help='Subdomain enumeration module')
    enum_parser.add_argument('--target', required=True, help='Target domain')
    enum_parser.add_argument('--merge-results', action='store_true', help='Merge subdomain results')
    enum_parser.add_argument('--check-alive', action='store_true', help='Check which subdomains are alive')
    
    # Information module
    info_parser = subparsers.add_parser('info', help='Information gathering module')
    info_parser.add_argument('--target', required=True, help='Target domain')
    
    # Crawling module
    crawl_parser = subparsers.add_parser('crawl', help='Crawling module')
    crawl_parser.add_argument('--target', required=True, help='Target domain')
    crawl_parser.add_argument('--live', action='store_true', help='Run live crawling with katana')
    crawl_parser.add_argument('--archive', action='store_true', help='Run archive crawling with waybackurls')
    
    # Path finder module
    path_parser = subparsers.add_parser('path', help='Path finder module')
    path_parser.add_argument('--target', required=True, help='Target domain')
    
    # SSL/TLS module
    ssl_parser = subparsers.add_parser('ssl', help='SSL/TLS scanning module')
    ssl_parser.add_argument('--target', required=True, help='Target domain')
    
    # Vulnerability scanner
    vuln_parser = subparsers.add_parser('vuln', help='Vulnerability scanning with Nuclei')
    vuln_parser.add_argument('--target', required=True, help='Target domain')
    
    # Subdomain takeover detection
    take_parser = subparsers.add_parser('takeover', help='Subdomain takeover detection')
    take_parser.add_argument('--target', required=True, help='Target domain')
    
    # HTTP probing
    httpx_parser = subparsers.add_parser('httpx', help='HTTP probing with Httpx')
    httpx_parser.add_argument('--target', required=True, help='Target domain')
    
    # GetAllURLs
    gau_parser = subparsers.add_parser('gau', help='GetAllURLs from multiple sources')
    gau_parser.add_argument('--target', required=True, help='Target domain')
    
    # Amass enumeration
    amass_parser = subparsers.add_parser('amass', help='Amass comprehensive enumeration')
    amass_parser.add_argument('--target', required=True, help='Target domain')
    
    # Technology detection
    tech_parser = subparsers.add_parser('tech', help='Technology detection')
    tech_parser.add_argument('--target', required=True, help='Target domain')
    
    # Output viewer module
    output_parser = subparsers.add_parser('output', help='Output viewer module')
    output_parser.add_argument('--list', action='store_true', help='List all output files')
    output_parser.add_argument('--file', help='Show content of specific output file')
    
    # AI assistant module
    ai_parser = subparsers.add_parser('ai', help='AI assistant module')
    ai_parser.add_argument('--query', required=True, help='Query to send to AI')
    ai_parser.add_argument('--api-key', help='OpenAI API key')
    
    # Settings module
    settings_parser = subparsers.add_parser('settings', help='Settings module')
    

    
    args = parser.parse_args()
    
    print_header()
    
    if args.module == 'enum':
        if args.merge_results:
            merge_subdomain_files(args.target)
        elif args.check_alive:
            check_alive_subdomains(args.target)
        else:
            enumerate_subdomains(args.target)
    
    elif args.module == 'info':
        run_whois(args.target)
    
    elif args.module == 'crawl':
        if args.archive:
            run_waybackurls(args.target)
        else:
            run_katana(args.target)
    
    elif args.module == 'path':
        run_admin_finder(args.target)
    
    elif args.module == 'ssl':
        run_sslscan(args.target)
    
    elif args.module == 'vuln':
        run_nuclei(args.target)
    
    elif args.module == 'takeover':
        run_subjack(args.target)
    
    elif args.module == 'httpx':
        run_httpx(args.target)
    
    elif args.module == 'gau':
        run_gau(args.target)
    
    elif args.module == 'amass':
        run_amass(args.target)
    
    elif args.module == 'tech':
        run_technology_detection(args.target)
    
    elif args.module == 'output':
        if args.file:
            show_file_content(args.file)
        elif args.list:
            list_outputs()
        else:
            list_outputs()
    
    elif args.module == 'ai':
        run_ai_assistant(args.query, args.api_key)
    
    elif args.module == 'settings':
        show_settings()
    

    
    print("\n[+] Operation completed.")

if __name__ == '__main__':
    main()
